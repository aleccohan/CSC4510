#include "general.h"

/* stmt_list
 *
 * <stmt_list> → {<stmt_list>} <stmt> NEWLINE
 */
int stmt_list() 
{
   printf("Enter <stmt_list>\n");

   int right,left,operation;

   while ( nextToken != NEWLINE ) {
   	left = stmt();
   	lex();
   }

   printf("Exit <stmt_list>\n");

   cout << endl;
   cout << "exiting stmt_list RETURNING " << left << endl;
   return left;
} /* End of function stmt_list */

/* stmt
 *
 * <stmt> → {id = } <expr> | DUMP | QUIT
 */
int stmt() 
{
   printf("Enter <stmt>\n");
   int left;

   if ( nextToken == DUMP ) {
   	s->dump();
   } else if ( nextToken == QUIT ) {
   	exit(1);
   /*} else if ( nextToken == IDENT ) {
   	var_pos = s->lookup(lexeme);
   	lex();
   	if ( nextToken == ASSIGN_OP ){
                lex();
   		var_pos->val = left = expr();
                
   	} 
      else{
         lex();
         left = expr();
      }
   } else if ( nextToken == INT_LIT ){
      left = expr();
   */} else if(nextToken == IDENT || nextToken == INT_LIT){
      left = expr();
   }
   else {
   	error("expected DUMP, QUIT, assignment, or expression");
   }

   printf("Exit <stmt>\n");

   cout << endl;
   cout << "exiting stmt RETURNING " << left << endl;
   return left;
} /* End of function stmt_list */

/* expr
   Parses strings in the language generated by the rule:
   <expr> -> <term> {(+ | -) <term>}
 */
int expr() 
{
   printf("Enter <expr>\n");

   int right,left,operation;

   /* Parse the first term */
   left = term();
   //left = number;
   cout << " IN EXPR left is = " << left << endl;

   /* As long as the next token is + or -, get
      the next token and parse the next term */
   while (nextToken == ADD_OP || nextToken == SUB_OP) {
      operation = nextToken;
      lex();
      right=term();
      cout << " IN EXPR right is = " << right << endl;
      if(operation == ADD_OP)
         left+=right;
      else if(operation == SUB_OP)
         left-=right;
      else
         error("expected - or +");
   }
   printf("Exit <expr>\n");

   cout << endl;
   cout << "exiting expr RETURNING " << left << endl;
   return left;
} /* End of function expr */


/* term
 *  Parses strings in the language generated by the rule:
 *  <term> -> <sfactor> {(* | /) <sfactor>)
 */
int term() 
{
   printf("Enter <term>\n");
   /* Parse the first factor */
   
   int right,left,operation;

   left=sfactor();
   /* As long as the next token is * or /, get the
      next token and parse the next factor */
   while (nextToken == MULT_OP || nextToken == DIV_OP) {
      operation = nextToken;
      lex();
      right=sfactor();
      if(operation == MULT_OP)
         left*=right;
      else if(operation == DIV_OP)
         left/=right;
      else
         error("expected * or /");
   }
   printf("Exit <term>\n");

   cout << endl;
   cout << "exiting term RETURNING " << left << endl;
   return left;
} /* End of function term */

/* sfactor
 * Parses strings in the language generated by the rule:
 * 
 *   <sfactor> -> - <efactor> | <efactor>
 *
 */
int sfactor() 
{
   printf("Enter <sfactor>\n");
   int val;
   /* Determine which RHS */
   if ( nextToken == SUB_OP ) {
      lex();
      val = efactor();
      val = -1 * val;
   } else {
      val = efactor();
   }
   printf("Exit <sfactor>\n");
   cout << endl;
   cout << "exiting sfactor RETURNING " << val << endl;
   return val;
}/* End of function efactor */

/* efactor
 * Parses strings in the language generated by the rule:
 * 
 *  <efactor> → {<pfactor> ^} <pfactor>
 *
 */
int efactor() 
{
   printf("Enter <efactor>\n");
   int left, right, operation;
   /* Determine which RHS */
   if ( nextToken == EXP_OP) {
     	while( nextToken == EXP_OP ) {
     		left = pfactor();
     		lex();
     		right = pfactor();
     		left = pow(left,right);
     	}
   } // we should ABSOLUTELY check for something else here
   else
      left = pfactor();

   printf("Exit <efactor>\n");
   cout << endl;
   cout << "exiting efactor RETURNING " << left << endl;
   return left;
}/* End of function efactor */

/* pfactor
 * Parses strings in the language generated by the rule:
 * 
 *   <pfactor> -> id | int_constant | ( <expr> )
 *
 */
int pfactor() 
{
   printf("Enter <pfactor>\n");
   int val;
   /* Determine which RHS */
   if (nextToken == IDENT || nextToken == INT_LIT){
      /* Get the next token */
      if(nextToken == INT_LIT)
         val = number;
      else
         val = var_pos->val;
      lex();
      //if assign op do expr
      // var_pos->val = expr();
      if(nextToken == ASSIGN_OP){
         item * temp;
         temp = var_pos;
         lex();
         temp->val = val = expr();
      }
   }
   /* If the RHS is ( <expr> ), call lex to pass over the left 
      parenthesis, call expr and check for the right parenthesis */
   else if (nextToken == LEFT_PAREN) {
         lex();
         val = expr();
         if (nextToken == RIGHT_PAREN)
            lex();
         else
            error("left without right paren");
   } else {
   /* It was not an id, an integer literal, or a left
       parenthesis */
       error("expected an id, integer, or a left paren");
   } /* End of else */
   printf("Exit <pfactor>\n");
   cout << endl;
   cout << "exiting pfactor RETURNING " << val << endl;
   return val;
}/* End of function pfactor */

void error(const char *message)
{
   printf("Error: %s\n",message);
}
